# path: core/exploit_manager.py

import time
import requests
import random
import asyncio 
import threading 
from typing import Dict, Any, List, Optional
import logging 
import json # Faz 38: Gelen JSON payload'unu ayrıştırmak için eklendi

class ExploitManager:
    """
    PARS EXPLOIT MANAGER (v24.2 - FAZ 38 RCE ZEKASI)
    
    Zafiyetlerin manuel olarak doğrulanmasını sağlar ve yapay zeka (Neural Engine) 
    üzerinden sömürü önerileri alır.
    """
    
    def __init__(self, logger_callback, engine_instance):
        self.log = logger_callback
        self.engine = engine_instance
        
        # Hazır Exploit Şablonları
        self.exploit_templates = {
            "RCE_TIME_BASED": "sleep 5",
            "RCE_ECHO": "; echo PARS_EXPLOIT_SUCCESS",
            "LFI_PASSWD": "../../../../../etc/passwd",
            "SQLI_UNION": "' UNION SELECT 1, 'PARS_SQLI', 3--",
            "XSS_ALERT": "<script>alert('PARS')</script>"
        }

    def generate_exploit_suggestion(self, vuln_data: dict) -> str:
        """Zafiyet verisine göre otomatik bir sömürü önerisi oluşturur (Hızlı Tahmin)."""
        category = vuln_data.get('category')
        
        if category == "SQLI":
            return "sqlmap -u TARGET --batch --dbs"
        elif category == "XSS":
            return "Kullanıcı girdisine <img src=x onerror=alert(1)> enjekte et."
        elif category == "RCE_SSRF":
            return "OOB (Out-of-Band) etkileşimi için DNS ping payload'u kullan."
        elif category == "LFI":
            return "Base64 wrapper ile kaynak kodu okumayı dene: php://filter/convert.base64-encode/resource=index.php"
        
        return "Manuel doğrulama önerilir."

    async def _get_ai_analysis(self, vuln_data: Dict[str, Any], context: str = ""):
        """
        AI (Neural Engine) üzerinden derinlemesine analiz talep eder.
        """
        if not self.engine.neural_engine.is_active:
            self.log("[AI_ANALİZ] Yapay Zeka Motoru pasif. API Key gerekli.", "WARNING")
            return
            
        # Zafiyet mesajını ve bağlamı birleştir
        analysis_data = {
            "category": vuln_data.get('category', 'UNKNOWN'),
            "message": vuln_data.get('message', 'No details.'),
            "context": context
        }
        
        self.log("[AI_ANALİZ] Gemini'ye Taktik Analiz İsteği Gönderiliyor...", "INFO")
        
        # Yapay zekadan analiz ve payload iste
        try:
            analysis_result = await self.engine.neural_engine.analyze_vulnerability(analysis_data)
        except Exception as e:
            analysis_result = f"AI Analiz Hatası: {str(e)[:50]}"
            self.log(f"[AI_ANALİZ] Kritik Hata: {analysis_result}", "CRITICAL")
            return

        # Payload üretme bağlamı
        payload_context = f"Hedef: {self.engine.target_url}. Kategoriler: {analysis_data['category']}. Mesaj: {analysis_data['message']}. Bağlam: {analysis_data['context']}"
        payload_suggestion = await self.engine.neural_engine.generate_payload(payload_context)
        
        # Sonucu logla

        self.log(f" AI Taktik Analizi ({analysis_data['category']})", "HEADER")
        self.log("════════════════════════════════════════════════════════════════", "HEADER")
        self.log(f" [Görüş]: {analysis_result}", "SUCCESS")
        self.log(f" [Payload Önerisi]: {payload_suggestion}", "SUCCESS")
        self.log("════════════════════════════════════════════════════════════════\n", "HEADER")

    def execute_manual_exploit(self, url: str, exploit_type: str, custom_payload: str = None):
        """
        Kullanıcının GUI üzerinden tetiklediği manuel exploit işlemini yürütür.
        FAZ 38: CRITICAL_AI_ANALYSIS tetiklenmesini yönetir.
        """
        self.log(f"\n>>> MANUAL EXPLOIT PROTOKOLÜ BAŞLATILIYOR: {exploit_type} <<<", "HEADER")
        
        # --- FAZ 38: KRİTİK AI ANALİZİ ---
        if exploit_type == "CRITICAL_AI_ANALYSIS":
            try:
                # Engine'den gelen JSON payload'unu ayrıştır
                vuln_data_for_ai = json.loads(custom_payload)
                
                category = vuln_data_for_ai.get("category", "UNKNOWN")
                level = vuln_data_for_ai.get("level", "CRITICAL")
                message = vuln_data_for_ai.get("message", "No message")
                vuln_url = vuln_data_for_ai.get("url", self.engine.target_url)

                context = f"Tarama URL: {vuln_url}. Mesaj: {message}."

                def run_async_ai():
                    # Asenkron kodu senkron thread içinde çalıştırmak için loop başlat
                    try:
                        loop = asyncio.get_running_loop()
                    except RuntimeError:
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)
                    
                    loop.run_until_complete(self._get_ai_analysis(vuln_data_for_ai, context=context))

                threading.Thread(target=run_async_ai, daemon=True).start()
                self.log(f"[AI TİGER] {level} Zafiyet Derin Analiz Modu Başlatıldı (Background).", "SUCCESS")
                self.log("[AI TİGER] Analiz tamamlandığında sonuçlar konsolda görünecektir. (Gemini ile 10-20 saniye sürebilir)", "INFO")
                return
            
            except json.JSONDecodeError:
                self.log("[AI TİGER] HATA: AI Analizi için gelen veri (payload) JSON formatında değil.", "CRITICAL")
                return
            except Exception as e:
                self.log(f"[AI TİGER] KRİTİK HATA: AI Analiz başlatılırken beklenmedik hata: {str(e)}", "CRITICAL")
                return
        
        # --- Normal Exploit Yürütme Kodu (Simülasyon) ---
        
        payload = custom_payload if custom_payload else self.exploit_templates.get(exploit_type, "whoami")
        self.log(f"INIT │ Payload hazırlanıyor: {payload}", "INFO")
        
        proxies = None
        # Not: requests, aiohttp ile aynı proxy mantığını kullanır, ancak burada requests ile simülasyon yapılıyor.
        
        try:
            start_time = time.time()
            # requests kütüphanesi senkron çalışır. 
            time.sleep(random.uniform(0.5, 2.0))
            latency = time.time() - start_time
            
            self.log(f"RESPONSE │ Simülasyon Süresi: {latency:.2f}s", "INFO")
            
            if "RCE" in exploit_type and "SUCCESS" in exploit_type:
                # Başarılı RCE senaryosu (Eski loglardan)
                self.log("\n[SYSTEM OS COMMAND EXECUTION SUCCESS]", "HEADER")
                self.log(f"[+] Output: uid=33(www-data)", "CRITICAL")
                self.log(f"[+] Exposed Secret: sk_live_f89sdbf923... (Firebase Admin Key)", "CRITICAL")
            
            elif "SQLI" in exploit_type:
                self.log("\n[CRITICAL DATA DUMP] - SQLi", "HEADER")
                self.log("[+] User: admin | Pass: $2y$10$xX8w...", "CRITICAL")

            else:
                 self.log("\n[EXPLOIT FAILED - SIMULATION ENDED]", "WARNING")
                
        except Exception as e:
            self.log(f"[ERROR] Exploit hatası: {str(e)}", "CRITICAL")
            
        self.log(">>> EXPLOIT PROTOKOLÜ TAMAMLANDI <<<", "HEADER")