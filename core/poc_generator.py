# path: core/poc_generator.py

from typing import Dict, Optional, List
from urllib.parse import urlparse
from datetime import datetime # YENİ: Tarih/Saat için import edildi

# --- HELPER FONKSİYON ---
def get_current_datetime_string() -> str:
    """Raporlar için güncel tarih ve saat bilgisini döndürür."""
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

class POCGenerator:
    """
    [FAZ 37: SRP TUTARLILIĞI KONTROLÜ]
    Otomatik Proof of Concept (Kanıt) ve Raporlama Motoru.
    Tespit edilen zafiyetleri HackerOne/Bugcrowd standartlarında rapor formatına çevirir.
    Hem CLI (curl) hem de Raw HTTP formatında kanıt üretir.
    """

    @staticmethod
    def generate_curl_command(url: str, method: str = "GET", headers: Dict[str, str] = None, data: str = None) -> str:
        """
        Verilen parametrelerle çalıştırılabilir bir cURL komutu oluşturur.
        """
        if headers is None:
            headers = {}
        
        # Temel komut
        command = [f"curl -i -s -k -X {method}"]

        # Headerları ekle
        for key, value in headers.items():
            # Tırnak işaretlerini escape et
            safe_value = value.replace('"', '\\"')
            command.append(f'-H "{key}: {safe_value}"')

        # Data/Payload varsa ekle
        if data:
            # Payload içindeki tek tırnakları bash için escape et
            safe_data = data.replace("'", "'\\''")
            command.append(f"-d '{safe_data}'")

        # URL'i en sona ekle
        command.append(f'"{url}"')

        return " ".join(command)

    @staticmethod
    def generate_raw_http(url: str, method: str = "GET", headers: Dict[str, str] = None, data: str = None) -> str:
        """
        Burp Suite Repeater vb. araçlar için Raw HTTP isteği oluşturur.
        """
        if headers is None:
            headers = {}

        parsed = urlparse(url)
        path = parsed.path if parsed.path else "/"
        if parsed.query:
            path += f"?{parsed.query}"
        
        host = parsed.netloc

        # Request Line
        raw_req = [f"{method} {path} HTTP/1.1"]
        
        # Host Header (Eğer headers içinde yoksa ekle)
        if "Host" not in headers:
            raw_req.append(f"Host: {host}")

        # Diğer Headerlar
        for key, value in headers.items():
            raw_req.append(f"{key}: {value}")

        # Header ve Body ayrımı
        raw_req.append("")
        
        if data:
            raw_req.append(data)
            
        return "\n".join(raw_req)

    @staticmethod
    def create_vulnerability_report(
        vuln_name: str,
        severity: str,
        target_url: str,
        description: str,
        impact: str,
        poc_inputs: Dict[str, any]
    ) -> str:
        """
        HackerOne / Bugcrowd stili Markdown raporu oluşturur.
        severity stringinin daima büyük harfe çevrilmesini sağlar (SRP Tutarlılığı).
        """
        method = poc_inputs.get('method', 'GET')
        headers = poc_inputs.get('headers', {})
        data = poc_inputs.get('data', None)

        curl_cmd = POCGenerator.generate_curl_command(target_url, method, headers, data)
        raw_http = POCGenerator.generate_raw_http(target_url, method, headers, data)
        
        # KRİTİK DÜZELTME: SRP Tutarlılığı için severity daima büyük harf olmalı.
        formatted_severity = severity.upper()

        report = f"""# Vulnerability Report: {vuln_name}

**Severity:** {formatted_severity}
**Target:** {target_url}
**Date:** {get_current_datetime_string()}

## 1. Summary
{description}

## 2. Technical Details & Impact
**Impact:**
{impact}

The attacker can manipulate the input via `{poc_inputs.get('attack_vector', 'HTTP Request')}` to trigger this behavior.

## 3. Steps to Reproduce (Proof of Concept)

### Option A: Curl Command
Run the following command in your terminal to verify the vulnerability:

```bash
{curl_cmd}
```

### Option B: Raw HTTP Request
You can copy this request into tools like Burp Suite Repeater:

```http
{raw_http}
```

## 4. Remediation / Fix Suggestions
1. Validate and sanitize all user inputs on the server side.
2. Use parameterized queries or prepared statements if this is an SQL injection.
3. Encode output data properly for the specific context (HTML, JS, etc.) if this is XSS.
4. Implement proper access controls and session validation.

---
*Generated by PARS - Synara Scanner Engine*
"""
        return report

# --- TEST BLOĞU ---
if __name__ == "__main__":
    # Test Verisi
    test_url = "http://example.com/search"
    test_headers = {"User-Agent": "PARS/v18.0", "Cookie": "session=admin"}
    test_payload = "<script>alert(1)</script>"
    
    # Curl Test
    print("--- Curl Command ---")
    print(POCGenerator.generate_curl_command(test_url, "POST", test_headers, test_payload))
    
    # Rapor Test
    print("\n--- Report Preview ---")
    print(POCGenerator.create_vulnerability_report(
        vuln_name="Reflected XSS",
        severity="Medium",
        target_url=test_url,
        description="Cross-site scripting vulnerability found in search parameter.",
        impact="Attacker can execute arbitrary JavaScript in victim's browser.",
        poc_inputs={"method": "POST", "headers": test_headers, "data": test_payload, "attack_vector": "Body Parameter"}
    ))